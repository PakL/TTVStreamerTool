

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>mod/twitchhelix.js &bull; TTVStreamerTool</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                     
                        <img src="img/logomark-white.svg" alt="logo">
                    
                     
                        <h1 class="navbar-item">TTVStreamerTool</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                 
                <div class="navbar-menu">
                    <div class="navbar-end">
                    
                        <div class="navbar-item">
                            <a href="https://github.com/PakL/TTVStreamerTool" target="_blank">Github</a>
                        </div>
                    
                        <div class="navbar-item">
                            <a href="https://pakl.dev/" target="_blank">pakl.dev</a>
                        </div>
                    
                        <div class="navbar-item">
                            <a href="https://dieweltzockt.de/" target="_blank">Die Welt Zockt</a>
                        </div>
                    
                    </div>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3>Tutorials</h3><ul><li><a href="tutorial-Getting Started.html">Getting Started</a></li><li><a href="tutorial-Streamdeck Shortcuts.html">Streamdeck Shortcuts</a></li></ul><h3>Classes</h3><ul><li><a href="Addons.html">Addons</a></li><li><a href="Channel.html">Channel</a></li><li><a href="Chat.html">Chat</a></li><li><a href="Cockpit.html">Cockpit</a></li><li><a href="Follows.html">Follows</a></li><li><a href="Overlays.html">Overlays</a></li><li><a href="ToolSettings.html">ToolSettings</a></li><li><a href="ToolUI.html">ToolUI</a></li><li><a href="TTVLogin.html">TTVLogin</a></li><li><a href="TTVTool.html">TTVTool</a></li><li><a href="TwitchChat.html">TwitchChat</a></li><li><a href="TwitchHelix.html">TwitchHelix</a></li><li><a href="TwitchTv.html">TwitchTv</a></li><li><a href="UIPage.html">UIPage</a></li></ul><h3>Events</h3><ul><li><a href="Channel.html#event:channeloffline">channeloffline</a></li><li><a href="Channel.html#event:channelonline">channelonline</a></li><li><a href="Channel.html#event:gamechange">gamechange</a></li><li><a href="Channel.html#event:statuschange">statuschange</a></li><li><a href="Channel.html#event:viewers">viewers</a></li><li><a href="Chat.html#event:autohostingyou">autohostingyou</a></li><li><a href="Chat.html#event:chatmessage">chatmessage</a></li><li><a href="Chat.html#event:cheer">cheer</a></li><li><a href="Chat.html#event:clearchat">clearchat</a></li><li><a href="Chat.html#event:clearuser">clearuser</a></li><li><a href="Chat.html#event:connected">connected</a></li><li><a href="Chat.html#event:hostingyou">hostingyou</a></li><li><a href="Chat.html#event:join">join</a></li><li><a href="Chat.html#event:names">names</a></li><li><a href="Chat.html#event:part">part</a></li><li><a href="Chat.html#event:roomstate">roomstate</a></li><li><a href="Chat.html#event:sendmessage">sendmessage</a></li><li><a href="Chat.html#event:usernotice">usernotice</a></li><li><a href="Chat.html#event:userstate">userstate</a></li><li><a href="Cockpit.html#event:channelleft">channelleft</a></li><li><a href="Cockpit.html#event:channelopen">channelopen</a></li><li><a href="Follows.html#event:follow">follow</a></li><li><a href="Overlays.html#event:command">command</a></li><li><a href="Overlays.html#event:hotkeys-unregistered">hotkeys-unregistered</a></li><li><a href="TTVLogin.html#event:complete">complete</a></li><li><a href="TTVTool.html#event:exit">exit</a></li><li><a href="TTVTool.html#event:load">load</a></li><li><a href="TwitchChat.html#event:action">action</a></li><li><a href="TwitchChat.html#event:autohostingyou">autohostingyou</a></li><li><a href="TwitchChat.html#event:capack">capack</a></li><li><a href="TwitchChat.html#event:clearchat">clearchat</a></li><li><a href="TwitchChat.html#event:clearmsg">clearmsg</a></li><li><a href="TwitchChat.html#event:clearuser">clearuser</a></li><li><a href="TwitchChat.html#event:close">close</a></li><li><a href="TwitchChat.html#event:connect">connect</a></li><li><a href="TwitchChat.html#event:error">error</a></li><li><a href="TwitchChat.html#event:hostingyou">hostingyou</a></li><li><a href="TwitchChat.html#event:incoming">incoming</a></li><li><a href="TwitchChat.html#event:join">join</a></li><li><a href="TwitchChat.html#event:message">message</a></li><li><a href="TwitchChat.html#event:mode">mode</a></li><li><a href="TwitchChat.html#event:mode+">mode+</a></li><li><a href="TwitchChat.html#event:mode-">mode-</a></li><li><a href="TwitchChat.html#event:motd">motd</a></li><li><a href="TwitchChat.html#event:names">names</a></li><li><a href="TwitchChat.html#event:notice">notice</a></li><li><a href="TwitchChat.html#event:outgoing">outgoing</a></li><li><a href="TwitchChat.html#event:part">part</a></li><li><a href="TwitchChat.html#event:raw">raw</a></li><li><a href="TwitchChat.html#event:reconnect">reconnect</a></li><li><a href="TwitchChat.html#event:registered">registered</a></li><li><a href="TwitchChat.html#event:roomstate">roomstate</a></li><li><a href="TwitchChat.html#event:usernotice">usernotice</a></li><li><a href="TwitchChat.html#event:userstate">userstate</a></li><li><a href="TwitchChat.html#event:whisper">whisper</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>mod/twitchhelix.js</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const request = require('request')

/**
 * @class TwitchHelix
 * @param {Object} options Options for the TwitchTv object
 * @param {String} [options.clientid] The client id of the twitch api app
 * @param {String} [options.redirecturi] The redirect uri of the twitch api app
 * @param {Array} [options.scope] An array of the permission scopes you might need
 * @param {String} [options.token] A string with an bearer token. If this is omitted token will be loaded from localStroage if possible
 */
class TwitchHelix {

	constructor(options) {
		/**
		 * The twitch api app client id that is necessary for request to the twitch api.
		 * @member {String}
		 */
		this.clientid = ''
		/**
		 * The redirect uri that ist set in the app settings.
		 * @member {String}
		 */
		this.redirecturi = ''
		/**
		 * An array with the required permission scopes.
		 * @member {Array}
		 */
		this.scope = []
		/**
		 * You know exactly what this is. Don't touch it!
		 * @private
		 * @member {String}
		 */
		this.token = ''
		/**
		 * User id of the logged in user.
		 * @member {String}
		 */
		this.userid = ''
		/**
		 * An object with all twitch user information. More information in the {@link https://dev.twitch.tv/docs/api/reference/#get-users|twitch api documentation}.
		 * @member {(null | Object)}
		 */
		this.userobj = null

		this.validstates = []
		this.ratelimitreset = -1;

		if(typeof(options.clientid) == 'string') this.clientid = options.clientid
		if(typeof(options.redirecturi) == 'string') this.redirecturi = options.redirecturi
		if(typeof(options.scope) == 'object') this.scope = options.scope

		if(typeof(options.token) == 'string') this.token = options.token
		else {
			if(typeof(window) !== "undefined" &amp;&amp; window.hasOwnProperty('localStorage')) {
				this.token = window.localStorage.getItem('tw_auth_token')
				if(this.token == null) this.token = ''
			}
		}
	}

	/**
	 * Returns a complete URL for the grant flow authentication and creates a state.
	 * 
	 * @returns {String}
	 */
	getAuthImplicitGrantFlowUrl() {
		var state = Math.floor(Date.now() / 1000).toString(16)
		this.validstates.push(state)

		return 'https://id.twitch.tv/oauth2/authorize' +
				'?response_type=token' +
				'&amp;client_id=' + this.clientid +
				'&amp;redirect_uri=' + encodeURIComponent(this.redirecturi) +
				'&amp;scope=' + this.scope.join('+') +
				'&amp;state=' + state +
				'&amp;force_verify=true'
	}

	/**
	 * Verifys if this returned state is one of the valid states and removes it from the local list.
	 * 
	 * @param {String} state The state that is returned by the OAuth auth flow
	 * @returns {Boolean}
	 */
	verifyState(state) {
		var i = this.validstates.indexOf(state)
		if(i >= 0) {
			this.validstates.splice(i, 1)
			return true
		}

		return false
	}

	/**
	 * Fills the user token and saves it in the localStorage.
	 * 
	 * @param {String} token The token that is returned by the OAuth2 auth flow
	 */
	setAuthToken(token) {
		if(typeof(token) != 'string') token = ''
		this.token = token

		if(typeof(window) !== "undefined" &amp;&amp; window.hasOwnProperty('localStorage')) {
			window.localStorage.setItem('tw_auth_token', token)
		}
	}

	/**
	 * Returns the twitch user auth token. Used for login in twitch irc or api requests for user related information.
	 * 
	 * @returns {String}
	 */
	getAuthToken() {
		return this.token
	}

	/**
	 * Returns true if user is logged in.
	 * 
	 * @returns {Boolean}
	 */
	isLoggedIn() {
		return (this.token.length > 0)
	}

	/**
	 * Prepares and executes a request to the twitch api and parses the response
	 * 
	 * @param {String} uri The URI to the api endpoint. Only the path is required, the host api.twitch.tv is prepended when the uri does not start with https://
	 * @param {Object} query An object with all request parameters. Is being encoded for the uri. Must be passed but can be empty.
	 * @param {Boolean} [authNeeded=false] Is user authorization required for this request. Oauth token is then passed on the request.
	 * @param {Object} [postdata={}] Optional post data. If there are properties in this object authNeeded is set to true and request method is set to put. Post data is serialized to a JSON string.
	 * @param {Boolean} [noretry=false] If this is set to true the request will not be retried after a server error response
	 * @param {String} [method=] Overwrite HTTP method
	 * @returns {Promise} Returns a Promise that resolves with a single response object if the request is done
	 * @example
	 * twitchtv.requestAPI(
	 *     // uri
	 *     '/helix/users',
	 * 
	 *     // query
	 *     {
	 *         login: ['pakl']
	 *     },
	 * 
	 *     // authNeeded
	 *     false
	 * ).then((data) => {
	 *     // Do something with data
	 * })
	 */
	requestAPI(uri, query, authNeeded, postdata, noretry, method) {
		const self = this
		if(typeof(authNeeded) != 'boolean') authNeeded = false
		if(typeof(query) != 'object' || query == null) query = {}
		if(typeof(noretry) != 'boolean') noretry = false
		if(typeof(method) !== 'string') method = ''

		if(typeof(postdata) !== 'object') {
			postdata = {}
		}
		if(typeof(uri) != 'string') return new Promise((r, rej) => { rej(new Error('uri must be of type string')) })

		if(Object.keys(postdata).length > 0) authNeeded = true

		let querystr = ''
		for(var key in query) {
			if(query.hasOwnProperty(key)) {
				let val = query[key]
				if(!Array.isArray(val)) {
					val = [val]
				}
				for(let i = 0; i &lt; val.length; i++) {
					querystr += '&amp;' + encodeURIComponent(key) + '=' + encodeURIComponent(val[i])
				}
			}
		}
		querystr = '?' + querystr.substr(1)
		if(querystr.length > 1) {
			uri += querystr
		}

		let headers = {}

		if(self.token.length > 0) {
			headers = {
				'Authorization': 'Bearer ' + self.token
			}
		} else if(!authNeeded) {
			headers = {
				'Client-ID': self.clientid
			}
		} else {
			return new Promise((res, rej) => {
				rej(new Error('User not logged in but authorization needed'))
			})
		}


		var poststr = ''
		if(Object.keys(postdata).length > 0) {
			poststr = JSON.stringify(postdata)
			headers['Content-Type'] = 'application/json'
		}

		console.log(`[API] Request for ${uri} started... authNeeded:${authNeeded}`)

		let overridehost = 'api.twitch.tv'
		if(uri.startsWith('https://')) {
			var parsedurl = url.parse(uri)
			overridehost = parsedurl.hostname
			uri = parsedurl.path
		}

		if(this.ratelimitreset > 0) {
			let timestamp = new Date().getTime()
			if(timestamp >= this.ratelimitreset) {
				this.ratelimitreset = -1
 			} else {
				 return new Promise((res, rej) => {
					rej(new Error('Rate limit exceeded. Try again later.'))
				})
			 }
		}

		return new Promise((resolve, reject) => {
			let requestOptions = {
				'method': 'GET',
				'url': 'https://' + overridehost + uri,
				'json': true,
				'headers': headers,
				'gzip': true,
				'strictSSL': true
			}
			if(Object.keys(postdata).length > 0) {
				requestOptions.method = 'PUT'
				requestOptions.body = postdata
			}
			if(method.length > 0) requestOptions.method = method.toUpperCase()
			request(requestOptions, (error, response, body) => {
				if(error) {
					reject(error)
					return
				}
				if(response.statusCode !== 200) {
					if(response.statusCode == 429) {
						self.ratelimitreset = parseInt(response.headers['ratelimit-reset']) * 1000
					} else if(response.statusCode >= 500 &amp;&amp; response.statusCode &lt; 600) {
						self.requestAPI(uri, {}, authNeeded, postdata, true).then((b) => {
							resolve(b)
						}).catch((er) => {
							reject(er)
						})
						return
					}
					if(typeof(body) == 'object' &amp;&amp; body.hasOwnProperty('message')) {
						if(body.message.length &lt;= 0 &amp;&amp; typeof(body.status) !== 'undefined' &amp;&amp; typeof(body.error) !== 'undefined') body.message = body.status + ' - ' + body.error
						reject(new Error(body.message))
					} else if(body == 'object') {
						reject(new Error(JSON.stringify(body)))
					} else {
						reject(new Error(body))
					}
					return
				}

				let data = null
				if(typeof(body) == 'object') {
					data = body
				} else {
					try {
						data = JSON.parse(body)
					} catch(e) {
						console.log('[API] Got unregular response:', body)
						reject(e)
						return
					}
				}
				resolve(data)
			})

		})
	}


	/**
	 * Gets information about one or more specified Twitch users. Users are identified by optional user IDs and/or login name. If neither a user ID nor a login name is specified, the user is looked up by Bearer token.
	 * 
	 * @param {Object} query An object with request parameters
	 * @param {String[]} [query.id] String array of user ids (max 100 entries)
	 * @param {String[]} [query.login] String array of user login names (max 100 entries)
	 * @returns {Promise} Returns a Promise that resolves with a single response object if the request is done
	 * @see {@link https://dev.twitch.tv/docs/api/reference/#get-users}
	 */
	getUsers(query)
	{
		var uri = '/helix/users'
		var opt = {}
		if(typeof(query) == 'object') {
			if(query.hasOwnProperty('id') &amp;&amp; (Array.isArray(query.id) || typeof(query.id) == "string")) opt.id = query.id
			if(query.hasOwnProperty('login') &amp;&amp; (Array.isArray(query.login) || typeof(query.login) == "string")) opt.login = query.login
		}
		return this.requestAPI(uri, opt, (typeof(opt.id) !== 'string' &amp;&amp; typeof(opt.login) !== 'string') ? true : false)
	}

	/**
	 * Gets information on follow relationships between two Twitch users. Information returned is sorted in order, most recent follow first. This can return information like “who is lirik following,” “who is following lirik,” or “is user X following user Y.”
	 * At minimum, from_id or to_id must be provided for a query to be valid.
	 * 
	 * @param {String} from_id User ID. The request returns information about users who are being followed by the from_id user. Will be omitted when empty.
	 * @param {String} to_id User ID. The request returns information about users who are following the to_id user. Will be omitted when empty.
	 * @param {Number} [first] Maximum number of objects to return. Maximum: 100. Default: 20.
	 * @param {String} [after] Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response.
	 * @returns {Promise} Returns a Promise that resolves with a single response object if the request is done
	 * @see {@link https://dev.twitch.tv/docs/api/reference/#get-users-follows}
	 */
	getUsersFollows(from_id, to_id, first, after)
	{
		var uri = '/helix/users/follows'
		var opt = {}

		if(typeof(from_id) == 'number') from_id = from_id.toString()
		if(typeof(to_id) == 'number') to_id = to_id.toString()

		if(typeof(from_id) == 'string' &amp;&amp; from_id.length > 0) opt.from_id = from_id
		if(typeof(to_id) == 'string' &amp;&amp; to_id.length > 0) opt.to_id = to_id
		if(typeof(first) == 'number' &amp;&amp; first > 0 &amp;&amp; first &lt;= 100) opt.first = first
		if(typeof(after) == 'string' &amp;&amp; after.length > 0) opt.after = after

		if(typeof(opt.from_id) !== 'string' &amp;&amp; typeof(opt.to_id) !== 'string') {
			return new Promise((r, reject) => {
				reject(new Error('One of either from_id or to_id must be defined'))
			})
		}
		return this.requestAPI(uri, opt, false)
	}


	/**
	 * Gets information about active streams. Streams are returned sorted by number of current viewers, in descending order. Across multiple pages of results, there may be duplicate or missing streams, as viewers join and leave streams.
	 * 
	 * @param {Object} query An object with request parameters
	 * @param {String} [query.after] Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query.
	 * @param {String} [query.before] Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query.
	 * @param {String[]} [query.community_id] Returns streams in a specified community ID. You can specify up to 100 IDs.
	 * @param {Number} [query.first] Maximum number of objects to return. Maximum: 100. Default: 20.
	 * @param {String[]} [query.game_id] Returns streams broadcasting a specified game ID. You can specify up to 100 IDs.
	 * @param {String[]} [query.language] Stream language. You can specify up to 100 languages.
	 * @param {String[]} [query.user_id] Returns streams broadcast by one or more specified user IDs. You can specify up to 100 IDs.
	 * @param {String[]} [query.user_login]  	Returns streams broadcast by one or more specified user login names. You can specify up to 100 names.
	 * @returns {Promise} Returns a Promise that resolves with a single response object if the request is done
	 * @see {@link https://dev.twitch.tv/docs/api/reference/#get-streams}
	 */
	getStreams(query)
	{
		var uri = '/helix/streams'
		var opt = {}
		if(typeof(query) == 'object') {
			if(query.hasOwnProperty('after') &amp;&amp; typeof(query.after) == "string") opt.after = query.after
			if(query.hasOwnProperty('before') &amp;&amp; typeof(query.before) == "string") opt.before = query.before
			if(query.hasOwnProperty('community_id') &amp;&amp; (Array.isArray(query.community_id) || typeof(query.community_id) == "string")) opt.community_id = query.community_id
			if(query.hasOwnProperty('first') &amp;&amp; typeof(query.first) == "number") opt.first = query.first
			if(query.hasOwnProperty('game_id') &amp;&amp; (Array.isArray(query.game_id) || typeof(query.game_id) == "string")) opt.game_id = query.game_id
			if(query.hasOwnProperty('language') &amp;&amp; (Array.isArray(query.language) || typeof(query.language) == "string")) opt.language = query.language
			if(query.hasOwnProperty('user_id') &amp;&amp; (Array.isArray(query.user_id) || typeof(query.user_id) == "string")) opt.user_id = query.user_id
			if(query.hasOwnProperty('user_login') &amp;&amp; (Array.isArray(query.user_login) || typeof(query.user_login) == "string")) opt.user_login = query.user_login
		}
		return this.requestAPI(uri, opt, false)
	}

	/**
	 * Creates a marker in the stream of a user specified by a user ID. A marker is an arbitrary point in a stream that the broadcaster wants to mark; e.g., to easily return to later.
	 * 
	 * @param {Object} query An object with request parameters
	 * @param {String} query.user_id ID of the broadcaster in whose live stream the marker is created.
	 * @param {String} [query.description] Description of or comments on the marker.
	 * @returns {Promise} Returns a Promise that resolves with a single response object if the request is done
	 * @see {@link https://dev.twitch.tv/docs/api/reference/#create-stream-marker}
	 */
	createStreamMarker(query)
	{
		var uri = '/helix/streams/markers'
		var post = {}
		if(typeof(query) == 'object') {
			if(query.hasOwnProperty('user_id') &amp;&amp; typeof(query.user_id) == "string") post.user_id = query.user_id
			if(query.hasOwnProperty('description') &amp;&amp; typeof(query.description) == "string") post.description = query.description
		}
		if(typeof(post.user_id) !== 'string') {
			return new Promise((r, reject) => {
				reject(new Error('user_id must be defined'))
			})
		}
		return this.requestAPI(uri, {}, true, post, true, 'POST')
	}

	/**
	 * Gets game information by game ID or name.
	 * At minimum, id or name must be provided for a query to be valid.
	 * 
	 * @param {String[]} id Game ID. At most 100 id values can be specified. Will be omitted when empty.
	 * @param {String[]} name Game name. The name must be an exact match. For instance, “Pokemon” will not return a list of Pokemon games; instead, query the specific Pokemon game(s) in which you are interested. At most 100 name values can be specified. Will be omitted when empty.
	 * @returns {Promise} Returns a Promise that resolves with a single response object if the request is done
	 * @see {@link https://dev.twitch.tv/docs/api/reference/#get-users-follows}
	 */
	getGames(id, name) {
		var uri = '/helix/games'
		var opt = {}

		if((Array.isArray(id) || typeof(id) == "string") &amp;&amp; id.length > 0) opt.id = id
		if((Array.isArray(name) || typeof(name) == "string") &amp;&amp; name.length > 0) opt.name = name

		if(
			typeof(opt.id) !== 'string' &amp;&amp; typeof(opt.name) !== 'string' &amp;&amp;
			!Array.isArray(opt.id) &amp;&amp; !Array.isArray(opt.name)
		) {
			return new Promise((r, reject) => {
				reject(new Error('One of either id or name must be defined'))
			})
		}
		return this.requestAPI(uri, opt, false)
	}


	/**
	 * Gets clip information by clip ID (one or more), broadcaster ID (one only), or game ID (one only).
	 * 
	 * @param {Object} query An object with request parameters
	 * @param {String[]} [query.id] ID of the clip being queried. Limit: 100.
	 * @param {String} [query.broadcaster_id] ID of the broadcaster for whom clips are returned. The number of clips returned is determined by the first query-string parameter (default: 20). Results are ordered by view count.
	 * @param {String} [query.game_id] ID of the game for which clips are returned. The number of clips returned is determined by the first query-string parameter (default: 20). Results are ordered by view count.
	 * @param {String} [query.after] Cursor for forward pagination: tells the server where to start fetching the next set of results, in a multi-page response. This applies only to queries specifying broadcaster_id or game_id. The cursor value specified here is from the pagination response field of a prior query.
	 * @param {String} [query.before] Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. This applies only to queries specifying broadcaster_id or game_id. The cursor value specified here is from the pagination response field of a prior query.
	 * @param {String} [query.ended_at] Ending date/time for returned clips, in RFC3339 format. (Note that the seconds value is ignored.) If this is specified, started_at also must be specified; otherwise, the time period is ignored.
	 * @param {Number} [query.first] Maximum number of objects to return. Maximum: 100. Default: 20.
	 * @param {String} [query.started_at] Starting date/time for returned clips, in RFC3339 format. (Note that the seconds value is ignored.) If this is specified, ended_at also should be specified; otherwise, the ended_at date/time will be 1 week after the started_at value.
	 * @returns {Promise} Returns a Promise that resolves with a single response object if the request is done
	 * @see {@link https://dev.twitch.tv/docs/api/reference/#get-clips}
	 */
	getClips(query) {
		var uri = '/helix/clips'
		var opt = {}

		if((Array.isArray(query.id) || typeof(query.id) == "string") &amp;&amp; query.id.length > 0) opt.id = query.id
		if(typeof(query.broadcaster_id) == "string" &amp;&amp; query.broadcaster_id.length > 0) opt.broadcaster_id = query.broadcaster_id
		if((typeof(query.game_id) == "string" &amp;&amp; query.game_id.length > 0) || typeof(query.game_id) == "number") opt.game_id = query.game_id

		if(typeof(query.after) == "string" &amp;&amp; query.after.length > 0) opt.after = query.after
		if(typeof(query.before) == "string" &amp;&amp; query.before.length > 0) opt.before = query.before
		if(typeof(query.ended_at) == "string" &amp;&amp; query.ended_at.length > 0) opt.ended_at = query.ended_at
		if(typeof(query.first) == "number") opt.first = query.first
		if(typeof(query.started_at) == "string" &amp;&amp; query.started_at.length > 0) opt.started_at = query.started_at

		if(
			typeof(opt.id) !== 'string' &amp;&amp; typeof(opt.broadcaster_id) !== 'string' &amp;&amp;
			typeof(query.game_id) !== "string" &amp;&amp; typeof(query.game_id) !== "number" &amp;&amp;
			!Array.isArray(opt.id)
		) {
			return new Promise((r, reject) => {
				reject(new Error('One of either id, broadcaster_id or game_id must be defined'))
			})
		}
		return this.requestAPI(uri, opt, false)
	}
}
module.exports = TwitchHelix</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>

<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a> on Mon Jul 29 2019 17:48:54 GMT+0200 (GMT+02:00)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers</a>
        </p>
    </div>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
