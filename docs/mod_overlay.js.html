

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>mod/overlay.js &bull; TTVStreamerTool</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                     
                        <img src="img/logomark-white.svg" alt="logo">
                    
                     
                        <h1 class="navbar-item">TTVStreamerTool</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                 
                <div class="navbar-menu">
                    <div class="navbar-end">
                    
                        <div class="navbar-item">
                            <a href="https://github.com/PakL/TTVStreamerTool" target="_blank">Github</a>
                        </div>
                    
                        <div class="navbar-item">
                            <a href="https://pakl.dev/" target="_blank">pakl.dev</a>
                        </div>
                    
                        <div class="navbar-item">
                            <a href="https://dieweltzockt.de/" target="_blank">Die Welt Zockt</a>
                        </div>
                    
                    </div>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3>Tutorials</h3><ul><li><a href="tutorial-Getting Started.html">Getting Started</a></li><li><a href="tutorial-Streamdeck Shortcuts.html">Streamdeck Shortcuts</a></li></ul><h3>Classes</h3><ul><li><a href="Addons.html">Addons</a></li><li><a href="Channel.html">Channel</a></li><li><a href="Chat.html">Chat</a></li><li><a href="Cockpit.html">Cockpit</a></li><li><a href="Follows.html">Follows</a></li><li><a href="Overlays.html">Overlays</a></li><li><a href="ToolSettings.html">ToolSettings</a></li><li><a href="ToolUI.html">ToolUI</a></li><li><a href="TTVLogin.html">TTVLogin</a></li><li><a href="TTVTool.html">TTVTool</a></li><li><a href="TwitchChat.html">TwitchChat</a></li><li><a href="TwitchHelix.html">TwitchHelix</a></li><li><a href="TwitchTv.html">TwitchTv</a></li><li><a href="UIPage.html">UIPage</a></li></ul><h3>Events</h3><ul><li><a href="Channel.html#event:channeloffline">channeloffline</a></li><li><a href="Channel.html#event:channelonline">channelonline</a></li><li><a href="Channel.html#event:gamechange">gamechange</a></li><li><a href="Channel.html#event:statuschange">statuschange</a></li><li><a href="Channel.html#event:viewers">viewers</a></li><li><a href="Chat.html#event:autohostingyou">autohostingyou</a></li><li><a href="Chat.html#event:chatmessage">chatmessage</a></li><li><a href="Chat.html#event:cheer">cheer</a></li><li><a href="Chat.html#event:clearchat">clearchat</a></li><li><a href="Chat.html#event:clearuser">clearuser</a></li><li><a href="Chat.html#event:connected">connected</a></li><li><a href="Chat.html#event:hostingyou">hostingyou</a></li><li><a href="Chat.html#event:join">join</a></li><li><a href="Chat.html#event:names">names</a></li><li><a href="Chat.html#event:part">part</a></li><li><a href="Chat.html#event:roomstate">roomstate</a></li><li><a href="Chat.html#event:sendmessage">sendmessage</a></li><li><a href="Chat.html#event:usernotice">usernotice</a></li><li><a href="Chat.html#event:userstate">userstate</a></li><li><a href="Cockpit.html#event:channelleft">channelleft</a></li><li><a href="Cockpit.html#event:channelopen">channelopen</a></li><li><a href="Follows.html#event:follow">follow</a></li><li><a href="Overlays.html#event:command">command</a></li><li><a href="Overlays.html#event:hotkeys-unregistered">hotkeys-unregistered</a></li><li><a href="TTVLogin.html#event:complete">complete</a></li><li><a href="TTVTool.html#event:exit">exit</a></li><li><a href="TTVTool.html#event:load">load</a></li><li><a href="TwitchChat.html#event:action">action</a></li><li><a href="TwitchChat.html#event:autohostingyou">autohostingyou</a></li><li><a href="TwitchChat.html#event:capack">capack</a></li><li><a href="TwitchChat.html#event:clearchat">clearchat</a></li><li><a href="TwitchChat.html#event:clearmsg">clearmsg</a></li><li><a href="TwitchChat.html#event:clearuser">clearuser</a></li><li><a href="TwitchChat.html#event:close">close</a></li><li><a href="TwitchChat.html#event:connect">connect</a></li><li><a href="TwitchChat.html#event:error">error</a></li><li><a href="TwitchChat.html#event:hostingyou">hostingyou</a></li><li><a href="TwitchChat.html#event:incoming">incoming</a></li><li><a href="TwitchChat.html#event:join">join</a></li><li><a href="TwitchChat.html#event:message">message</a></li><li><a href="TwitchChat.html#event:mode">mode</a></li><li><a href="TwitchChat.html#event:mode+">mode+</a></li><li><a href="TwitchChat.html#event:mode-">mode-</a></li><li><a href="TwitchChat.html#event:motd">motd</a></li><li><a href="TwitchChat.html#event:names">names</a></li><li><a href="TwitchChat.html#event:notice">notice</a></li><li><a href="TwitchChat.html#event:outgoing">outgoing</a></li><li><a href="TwitchChat.html#event:part">part</a></li><li><a href="TwitchChat.html#event:raw">raw</a></li><li><a href="TwitchChat.html#event:reconnect">reconnect</a></li><li><a href="TwitchChat.html#event:registered">registered</a></li><li><a href="TwitchChat.html#event:roomstate">roomstate</a></li><li><a href="TwitchChat.html#event:usernotice">usernotice</a></li><li><a href="TwitchChat.html#event:userstate">userstate</a></li><li><a href="TwitchChat.html#event:whisper">whisper</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>mod/overlay.js</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const ws = require('nodejs-websocket')
const fs = require('fs')
const url = require('url')
const http = require('http')
const {remote} = require('electron')
const {globalShortcut} = remote

const UIPage = require('./uipage')

/**
 * This module creates a http host for OBS/Xsplit overlays. Has an UI for setting hotkeys and controling 
 * 
 * @class Overlays
 * @extends {UIPage}
 * @param {ToolUI} toolui
 * @fires Overlays#hotkeys-unregistered
 * @fires Overlays#command
 */
class Overlays extends UIPage {

	constructor(toolui) {
		super('Overlays')
		this._ui = toolui
		const self = this

		this._visible = false

		this._subscriptions = {}

		/**
		 * The port for the WebSocket server. Connect to this port to listen for events.
		 * @member {Number}
		 */
		this.wsport = 8091
		/**
		 * The port for the overlay http server.
		 * @member {Number}
		 */
		this.overlayport = 8090
		this.overlayres = 'res/overlays/'
		this.repeatForNewClients = []

		/**
		 * Array of file endings that are being served. You can add your own, if you want.
		 * @member {Array&lt;String>}
		 */
		this.allowedFiles = ['.png', '.jpg', '.jpeg', '.gif', '.css', '.js', '.wav', '.mp3', '.m4a']
		this.fileMimeType = {
			'.html': 'text/html',
			'.png': 'image/png',
			'.jpg': 'image/jpeg',
			'.jpeg': 'image/jpeg',
			'.gif': 'image/gif',
			'.css': 'text/css',
			'.js': 'application/javascript',
			'.wav': 'audio/wav',
			'.mp3': 'audio/mpeg',
			'.m4a': 'audio/m4a'
		}

		/**
		 * The websocket server
		 * @member {nodejs-websocket.Server}
		 */
		this.wsserver = ws.createServer((conn) => { self.wsNewConnection(conn) }).listen(this.wsport)
		this.wsserver.on('error', (e) => { console.error(e) })
		console.log('[Overlay] Websocket server listening on ' + this.wsport)
		/**
		 * The http server
		 * @member {http.Server}
		 */
		this.overlayserver = http.createServer((req, resp) => { self.httpRequest(req, resp) }).listen(this.overlayport)
		console.log('[Overlay] HTTP server listening on ' + this.overlayport)

		
		this._appendOnLoad = []

		this.overlaySettingsPlaylistElement = null
		this.overlaySettingsVolumeElement = null
		this.overlaySettingsVolumeControlElement = null

		this.overlaySettingsOpen = false

		/** Music overlay settings */
		this.appendSetting('', this._ui.i18n.__('Overlay URL'), 'text', {attrid: 'music_overlay_url', set: 'music', setLabel: this._ui.i18n.__('Music Overlay'), readonly: true, default: 'http://localhost:' + self.overlayport + '/music.html', 'description': this._ui.i18n.__('Add #black to the end of the URL to get black text with white borders instead of white text with black borders.')})
		this.appendSetting('', this._ui.i18n.__('Black font'), 'checkbox', {set: 'music', readonly: true, default: 'http://localhost:' + self.overlayport + '/music.html', onchange: (e) => {
			if(e.target.checked) {
				document.querySelector('#music_overlay_url').value = 'http://localhost:' + self.overlayport + '/music.html#black'
			} else {
				document.querySelector('#music_overlay_url').value = 'http://localhost:' + self.overlayport + '/music.html'
			}
		}})
		this.appendSetting('', this._ui.i18n.__('Overlay volume control URL'), 'text', {attrid: 'music_volume_url', set: 'music', readonly: true, default: 'http://localhost:' + self.overlayport + '/send?music_volume=' + this.tool.settings.getString('overlay_music_volume', '50'), 'description': this._ui.i18n.__('This is a completely transparent overlay you can use in different OBS scenes to control the volume on scene changes. Change the number at the end to anything between 0 (mute) to 100 (way to loud).')})
		this.appendSetting('', this._ui.i18n.__('Overlay volume control command'), 'text', {attrid: 'music_volume_cmd', set: 'music', readonly: true, default: 'music_volume=' + this.tool.settings.getString('overlay_music_volume', '50'), 'description': this._ui.i18n.__('Use this command in an hotkey to change volume. Change the number at the end to anything between 0 (mute) to 100 (way to loud).')})
		this.appendSetting('', this._ui.i18n.__('Overlay skip track command'), 'text', {attrid: 'music_skip_track_cmd', set: 'music', readonly: true, default: 'music_skip_track', 'description': this._ui.i18n.__('Use this command in an hotkey to skip to the next track.')})
		this.appendSetting('', this._ui.i18n.__('Skip now'), 'button', {set: 'music', onclick: () => {
			self.broadcastWsMessage('music_skip_track')
		}})

		this.appendSetting('', '', 'separator', {set: 'music'})

		this.appendSetting('overlay_music_playlist', this._ui.i18n.__('Youtube playlist id: (has to be public)'), 'text', {set: 'music', default: 'PLRBp0Fe2Gpglq-J-Hv0p-y0wk3lQk570u', onchange: () => {
			self.broadcastWsMessage('music_playlist=' + self.overlayMusicPlaylist)
		}})

		this.appendSetting('overlay_music_volume', this._ui.i18n.__('Default volume'), 'range', {set: 'music', default: 50, min: 0, max: 100, step: 5})
		this.appendSetting('', this._ui.i18n.__('Live volume control'), 'range', {attrid: 'music_live_control', set: 'music', default: parseFloat(this.tool.settings.getString('overlay_music_volume', '50')), min: 0, max: 100, onchange: (e) => {
			self.broadcastWsMessage('live_music_volume=' + e.target.value)
			document.querySelector('#music_volume_url').value = 'http://localhost:' + self.overlayport + '/send?music_volume=' + e.target.value
			document.querySelector('#music_volume_cmd').value = 'music_volume=' + e.target.value
		}})

		/** Timer overlay settings */
		this.appendSetting('', this._ui.i18n.__('Overlay URL'), 'text', {attrid: 'timer_overlay_url', set: 'timer', setLabel: this._ui.i18n.__('Countdown Overlay'), readonly: true, default: 'http://localhost:' + self.overlayport + '/countdown.html', 'description': this._ui.i18n.__('Add #black to the end of the URL to get black text with white borders instead of white text with black borders.')})
		this.appendSetting('', this._ui.i18n.__('Black font'), 'checkbox', {set: 'timer', readonly: true, default: 'http://localhost:' + self.overlayport + '/countdown.html', onchange: (e) => {
			if(e.target.checked) {
				document.querySelector('#timer_overlay_url').value = 'http://localhost:' + self.overlayport + '/countdown.html#black'
			} else {
				document.querySelector('#timer_overlay_url').value = 'http://localhost:' + self.overlayport + '/countdown.html'
			}
		}})
		this.appendSetting('', this._ui.i18n.__('Overlay add time command'), 'text', {attrid: 'timer_add_cmd', set: 'timer', readonly: true, default: 'timer_add=5m', 'description': this._ui.i18n.__('Use this command in an hotkey to add time the countdown overlay. You can add time in this format: ##h##m##s; ##h adds hours, ##m adds minutes, ##s adds seconds. Every part is optional. Example: timer_add=1h30m0s or timer_add=90m')})
		this.appendSetting('', this._ui.i18n.__('Overlay set time target command'), 'text', {attrid: 'timer_set_cmd', set: 'timer', readonly: true, default: 'timer_set=12:00', 'description': this._ui.i18n.__('Use this command in an hotkey to let the countdown count down to a specific point in time. Format: YYYY-MM-DD hh:mm:ss; Hours must be in the 24 hour format, date and seconds are optional. If the given date is in the past nothing will happen. Example: timer_set=2018-09-08 13:00:00 or timer_set=15:00')})


		this.tool.once('load', () => {
			let hotkeySet = document.querySelector('#overlay_hotkeys_set')
			riot.mount(hotkeySet, {title: self._ui.i18n.__('Overlay hotkeys'), 'settings': []}, 'settingsset')
			let hotkeySetSet = document.querySelector('#overlay_hotkeys_set > fieldset')

			let hotkeys = document.createElement('overlayhotkeys')
			hotkeys.setAttribute('id', 'overlay_hotkeys')
			hotkeySetSet.appendChild(hotkeys)

			while(self._appendOnLoad.length > 0) {
				let s = self._appendOnLoad.shift()
				self.appendSetting(s.setting, s.label, s.type, s.options)
			}

			riot.mount(hotkeys, {'localstorage': window.localStorage})
		})
		this.tool.on('exit', () => {
			self.wsserver.close()
			console.log('[Overlay] Websocket server closing')
			self.overlayserver.close()
			console.log('[Overlay] HTTP server closing')
		})
	}

	/**
	 * Gives you the localized name of the page
	 * 
	 * @type {String}
	 * @override
	 * @readonly
	 */
	get localizedName() {
		return this.tool.i18n.__('Overlay settings')
	}

	get icon() {
		return '🖼️'
	}

	/**
	 * Shortcut to the tool
	 * 
	 * @type {TTVTool}
	 * @readonly
	 * @private
	 */
	get tool() {
		return this._ui.tool
	}

	/**
	 * Manages new websocket connections
	 * 
	 * @param {ws.Client} conn 
	 * @private
	 */
	wsNewConnection(conn) {
		const self = this
		console.log('[Overlay] New websocket connection')

		//this.wsConnections.push(conn)
		conn.on('text', function (str) {
			console.log('[Overlay][Websocket] > ' + str)
			if(str.startsWith('music_volume_update=')) {
				document.querySelector('#music_live_control').value = str.substr(20)
			}
			if(str.startsWith(':')) {
				if(str.startsWith(':please_repeat')) {
					self.repeatBroadcast(this)
				} else if(str.startsWith(':subscribe:')) {
					let cmd = str.substr(11)
					if(typeof(self._subscriptions[cmd]) == 'undefined') self._subscriptions[cmd] = []
					self._subscriptions[cmd].push(this)
				}
			}
		})
		conn.on('close', function (code, reason) {
			console.log('[Overlay] Websocket connection closed')

			// Clean client out of subscriptions
			for(let cmd in self._subscriptions) {
				if(!self._subscriptions.hasOwnProperty(cmd)) continue;
				let newSub = []
				let sub = self._subscriptions[cmd]
				for(let i = 0; i &lt; sub.length; i++) {
					if(sub[i] !== this) newSub.push(sub[i])
				}
				if(newSub.length == 0) {
					delete self._subscriptions[cmd]
				} else {
					self._subscriptions[cmd] = newSub
				}
			}
			//self.wsConnections.splice(self.wsConnections.indexOf(conn), 1)
		})
	}

	/**
	 * Broadcasts a message to all WebSocket connections
	 * 
	 * @param {String} message Message you want to send
	 */
	broadcastWsMessage(message) {
		if(typeof(message) != 'string') return
		this.repeatForNewClients.push({msg: message, time: new Date().getTime()})

		let sent = 0
		let subs = this.getSubscriptionsForMessage(message)
		for(let i = 0; i &lt; subs.length; i++) {
			subs[i].sendText(message)
			sent++
		}

		if(sent > 0)
			console.log('[Overlay][Websocket] &lt; ' + message + ' (' + sent + 'x)')

		/**
		 * Fires when a command is fired (wether or not a overlay has received it)
		 * @event Overlays#command
		 * @param {String} command The command or message string that was sent
		 */
		this.emit('command', message)
	}

	repeatBroadcast(client) {
		let repeats = []
		this.repeatForNewClients.forEach((val) => {
			if(new Date().getTime() - 1000 &lt;= val.time) {
				repeats.push(val)
				let subs = this.getSubscriptionsForMessage(message)
				if(subs.indexOf(client) >= 0) {
					console.log('[Overlay][Websocket] Repeating for new client: &lt; ' + val.msg)
					client.sendText(val.msg)
				}
			}
		})
		this.repeatForNewClients = repeats
	}

	getSubscriptionsForMessage(message) {
		let subs = []
		for(let cmd in this._subscriptions) {
			if(!this._subscriptions.hasOwnProperty(cmd)) continue;
			if(!message.startsWith(cmd)) continue;
			let sub = this._subscriptions[cmd]
			for(let i = 0; i &lt; sub.length; i++) {
				subs.push(sub[i])
			}
		}
		return subs
	}

	/**
	 * Manages http requests
	 * 
	 * @private
	 * @param {http.IncomingMessage} req
	 * @param {http.ServerResponse} resp 
	 */
	httpRequest(req, resp){
		const self = this
		console.log('[Overlay][HTTP] > ' + req.method + ' ' + req.url)
		let u = url.parse(req.url)
		let filename = u.pathname
		if(filename.length > 0) filename = filename.substr(1)
		let i = filename.lastIndexOf(".")
		let allowed = (this.allowedFiles.indexOf(filename.substr(i).toLowerCase()) >= 0)
		let access = false
		let rp = this.overlayres
		try {
			fs.accessSync(rp + filename)
			access = true
		} catch(e) {}
		if(!access) {
			try {
				let addons = fs.readdirSync('addons/')
				for(let i = 0; i &lt; addons.length; i++) {
					if(fs.existsSync('addons/' + addons[i] + '/' + rp + filename)) {
						rp = 'addons/' + addons[i] + '/' + rp
						access = true
						break
					}
				}
			} catch(e) {}
		}
		if(!access) {
			try {
				let asars = fs.readdirSync('resources/')
				for(let i = 0; i &lt; asars.length; i++) {
					let n = asars[i].toLowerCase()
					if(n.substr(n.lastIndexOf('.')) == '.asar') {
						if(fs.existsSync('resources/' + asars[i] + '/' + rp + filename)) {
							rp = 'resources/' + asars[i] + '/' + rp
							access = true
							break
						}
					}
				}
			} catch(e) {}
		}
		if(!access) {
			try {
				if(fs.existsSync(filename)) {
					rp = ''
					access = true
				}
			} catch(e) {}
		}
		if(u.pathname == '/' || u.pathname.substr(u.pathname.lastIndexOf('.')) == '.html') {
			if(u.pathname.substr(0, 1) == "/") u.pathname = u.pathname.substr(1)
			let name = u.pathname.substring(0, u.pathname.lastIndexOf('.'))
			if(name == 'index') {
				console.log('[Overlay][HTTP] &lt; 400, Content-Length: 0')
				resp.writeHead(400, {'Content-Length': 0})
				resp.end()
			} else {
				try {
					fs.accessSync(rp + name + '.html')
					let doc = fs.readFileSync(rp + name + '.html', { 'encoding': 'utf8' })
					doc = doc.replace(/\{__WS_PORT__\}/, this.wsport)
					doc = doc.replace(/\{__MUSIC_PLAYLIST__\}/, this.overlayMusicPlaylist)
					doc = doc.replace(/\{__MUSIC_VOLUME__\}/, this.overlayMusicVolume)

					console.log('[Overlay][HTTP] &lt; 200, Content-Length: '+Buffer.byteLength(doc, 'utf8'))
					resp.writeHead(200, {'Content-Length': Buffer.byteLength(doc, 'utf8'), 'Content-Type': this.fileMimeType['.html']})
					resp.end(doc)
				} catch(e) {
					console.log('[Overlay][HTTP] &lt; 404, Content-Length: 0')
					resp.writeHead(404, {'Content-Length': 0})
					resp.end()
				}
			}
		} else if(filename == 'send') {
			this.broadcastWsMessage(u.query)

			console.log('[Overlay][HTTP] &lt; 200, Content-Length: 0')
			resp.writeHead(200, {'Content-Length': 0, 'Content-Type': 'text/plain'})
			resp.end('')
		} else if(i > 0 &amp;&amp; access &amp;&amp; allowed) {
			let doc = ''
			let fending = filename.substr(i).toLowerCase()
			if(fending == '.js') {
				doc = fs.readFileSync(rp + filename, { 'encoding': 'utf8' })
				doc = doc.replace(/\{__WS_PORT__\}/, this.wsport)
			} else {
				doc = fs.readFileSync(rp + filename)
			}
			console.log('[Overlay][HTTP] &lt; 200, Content-Length: '+doc.length)
			resp.writeHead(200, {
				'Content-Length': doc.length,
				'Content-Type': (typeof(this.fileMimeType[fending]) === 'string' ? this.fileMimeType[fending] : 'application/octet-stream')
			})
			resp.end(doc)
		} else if(!access) {
			console.log('[Overlay][HTTP] &lt; 404, Content-Length: 0')
			resp.writeHead(404, {'Content-Length': 0})
			resp.end()
		} else {
			console.log('[Overlay][HTTP] &lt; 400, Content-Length: 0')
			resp.writeHead(400, {'Content-Length': 0})
			resp.end()
		}
	}

	get overlayMusicPlaylist() {
		return this.tool.settings.getString("overlay_music_playlist");
	}

	get overlayMusicVolume() {
		return parseInt(this.tool.settings.getString("overlay_music_volume"));
	}

	/**
	 * Disable all registered Hotkeys
	 */
	disableOverlayHotkeys() {
		globalShortcut.unregisterAll()
		/**
		 * Fires when hotkeys were unregistered
		 * @event Overlays#hotkeys-unregistered
		 */
		this.emit('hotkeys-unregistered')
		console.log('[Overlay] All hotkeys disabled')
	}

	/**
	 * Saves all hotkeys from the form
	 * 
	 * @private
	 */
	renewOverlayHotkeys() {
		const self = this
		this.disableOverlayHotkeys()

		let hotkeys = document.querySelector('#overlay_hotkeys').querySelectorAll('hotkey')
		let hotkeyStorage = []
		for(let i = 0; i &lt; hotkeys.length; i++) {
			let accelerator = hotkeys[i].querySelector('.hotkeyaccelerator').value
			let command = hotkeys[i].querySelector('.hotkeycommand').value

			if(accelerator.length > 0 &amp;&amp; command.length > 0) {
				globalShortcut.register(accelerator, () => { self.broadcastWsMessage(command) })
				hotkeyStorage.push({accelerator: accelerator, cmd: command})
			}
		}
		console.log('[Overlay] Registered ' + hotkeys.length + ' hotkeys')
		this.tool.settings.setJSON('overlay_hotkeys', hotkeyStorage)
	}

	/**
	 * Open the cockpit page
	 * 
	 * @override
	 */
	open() {
		this._visible = true
		document.querySelector('#content_overlays').style.display = 'block'
	}

	/**
	 * Closes the cockpit page
	 * 
	 * @override
	 */
	close() {
		this._visible = false
		document.querySelector('#content_overlays').style.display = 'none'
	}


	/**
	 * 
	 * @param {String} setting 
	 * @param {String} label 
	 * @param {String} type 
	 * @param {Object} options 
	 */
	appendSetting(setting, label, type, options) {
		const self = this

		type = type.toLowerCase()
		if(['text', 'checkbox', 'select', 'password', 'separator', 'button', 'range', 'number', 'date', 'time'].indexOf(type) &lt; 0) return
		//if((setting.length &lt;= 0 || label.length &lt;= 0) &amp;&amp; type != 'separator') return


		let options_default = {
			set: 'unsorted',
			setLabel: '',
			description: '',
			selection: {},
			onchange: null,
			onclick: null,
			default: null
		}
		if(typeof(options) == 'object') {
			options = Object.assign(options_default, options)
		} else {
			options = options_default
		}
		
		options.type = type
		options.setting = setting
		options.label = label

		let content_settings = document.querySelector('#content_overlays')
		if(content_settings === null) {
			this._appendOnLoad.push({setting: setting, label: label, type: type, options: options})
			return
		}

		// Getting the fieldset the option belongs to or creates a new one if it doesn't exist
		let settings_set = document.querySelector('#osettings_set_' + options.set)
		if(settings_set === null) {
			let fieldsetElement = document.createElement('settingsset')
			fieldsetElement.id = 'osettings_set_' + options.set
			content_settings.appendChild(fieldsetElement)
			riot.mount(fieldsetElement, {'title': options.setLabel, 'settings': []}, 'settingsset')
			settings_set = fieldsetElement
		}

		settings_set._tag.addSetting(options)
	}

}

module.exports = Overlays</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>

<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.3</a> on Sun Aug 18 2019 12:47:45 GMT+0200 (GMT+02:00)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers</a>
        </p>
    </div>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
